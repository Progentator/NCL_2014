As always.  I'm not spending too much time writing these up, as I really don't know how interested people are.  Feel free to contact me (ipp) on Freenode if you want a better write up//explanation.

All of these challenge are similiar, you connect to a port (1234) and after sending the port a bunch of junk it dumps a binary file.  The easiest way is to get the program to do this is to create a file with ~500 characters and perform a `ncat <ip> 1234 < <500_char_file> > <output_file>`.  I will be doing Exploit 5, which should make it easy to go both 6 and 4.  Ideally, you would use IDA to do this, but since they are 64-Bit it requires the Pro Version which if you have you should already know enough to do this.  I will be doing this in Evans DeBugger (EDB) as it is free and will do the job.  

The hardest part of these challenges isn't the actual debugging but understanding the program.  First thing I did was run a strings on the program, the key things you notice is flag.txt which indicates the flag is not in the program.  So somehow you need to get that program to read that file.  There isn't much else to tell in the strings output, unless you are clairvoyant or debuged a previous challenge.  

The next step i did was run `ltrace ./exploit5.bin`, in order to see what is happening.  I see fget, which is a deprecated function that shouldn't be in use anymore due to it being prone to buffer overflows.  I entered a bunch of text as I did earlier to get it to dump it over the network.  After 257 bytes, the program crashed which sounds great because $(LotsOfCharacters + fget = Crash) means a buffer overflow is possible but this is not the case!  Thanks to ltrace, it is obvious the program is crashing because it attempted to open c2; not because of a buffer overflow.  The logical thing to do is to create c2 and run the program again; if you do this you will see it exit gracefully and dump the contents of c2.  So that is most likely the name of the program itself on the remote server, as that would mimic the behavior.

That may not seem useful but knowing there is no buffer overflow exploit is great because going down that rabbit hole wastes valuable time.  The next step is to see how to terminate fget.  A quick google search tells us that the EOT Character can terminate that and it is sent by pressing Ctrl+D.  Execute the exploit again and after entering a line press ctrl+d.  The program does something different, it outputs "Thank You!" and not the contents of c2.  So we now know that if we send too many characters, the program will terminate and if we send a terminated string; it will say Thank You!.  That's enough information to know that there probably is a secret string to get the program to read out of "flag.txt".  So lets open up EDB and see exactly what is happening!

Once EDB is open and the program is open.  Press the Run Button, which is below the "Debug" on the menu bar.  Then press it again and hit the STOP Button.  What we wanted to do is bypass a bunch of the initialization pieces of the program, this skipped ahead to where the fget was waiting for input.  Now that the program is paused, open the EDB Output window and enter abc123, Enter, ctrl+d, enter.  What this did was send 'abc123\n'+EOT to the program.  Press F7 or 'Step Into' and you will see the string get loaded into the RSI Memory Register.  Please note: This is a very rudimentary way of going about using the debugger but its simple and works, I would highly look into learning how to use a debugger if you completed or understood all the other exploits.

Screenshot (re1.png) one shows this, we could step through the program and analyze everything but for the first time lets just hold F7 and see what happens within the memory.  After a while you will see it turn the string into 234`ab (re2.png), and if you had actually been reading the ASM Code you would of noticed it was just adding 2f to each character; which is 47 (Very Common Rotation Cipher).  If you weren't reading the ASM, you would notice it is odd that both "abc" and "123" stayed sequential and may have ran longer strings through the program to help determine what is happening.  Anyways, hold F7 again and keep looking within the memory.

Right after the string is fully encoded, it loads something really weird into rdx (re3.png).  It should look familiar because that was in the strings output of the program when we first loaded it up!  If you keep stepping forward you will see the "Thank You!" message.  The program ended.  So what did we learn?

<ul>
	<li>It only ends after 257 characters or EOT is sent</li>
	<li>It adds 2F to Each character or ROT47 it</li> 
	<li>After the Rot47 is done, it will load a string into memory</li>
	<li>Shortly After, the program displays Thank You and exits.</li>
</ul>

Even without reading the Assembly (re4.png) You should be able to come to the conclusion that the program was comparing the input and preloaded string.  So lets Rot47 the string and enter it the same way we had done abc123 (with ltrace).  After you paste in " K     Y h   WU 6]0P   OR ]]  F <    OOU G) nms"      C_    :d 4K4K4K444"-Enter-CtrlD, you will see the program error out after attempting to read Flag.txt.  Now you just need to send that to the server and it will spit out the flag!  In order to do that I used ncat.  Noteice I said ncat, not telnet, nc, or netcat; use ncat.  I don't think the others will send EOT via ctrl+d.

Thats it.  All of the exploit challenges were really similiar and could be solved via that method.  Some of them may use fread which terminates via a NULL Byte instead of EOT.  In EDB you can send that character just by closing the output window.
